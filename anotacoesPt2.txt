spring boot parte dois

aula 1 atividade 2 - PAGINAÇÃO
"modificação no método lista dentro do controller para adicionar paginação"
na listagem dos resultados. envolveu adaptação na interface TopicoRepository e 
na classe TopicoDto, método converter.

aula 1 atividade 4 - VANTAGEM DE UTILIZAR A INTERFACE PAGE

> Como vimos no vídeo anterior, foi necessário alterar o retorno do método lista, de List<Topico>, para Page<Topico>. 
Qual a vantagem de devolver um objeto Page, ao invés de um List? 
**Adicionar dados sobre a paginação no JSON de resposta**
Ao utilizar o objeto Page, além de devolver os registros, o Spring também devolve informações sobre a paginação no JSON de resposta , 
como número total de registros e páginas.

aula 1 atividade 5 - ORDENAÇÃO
"melhorada a listagem paginada dentro do controller e atribuída opção de ordenação personalizada dos resultados pelo cliente alterando a lógica do método lista"
foi adicionado o atributo ordenação como RequestParam e dentro do PageRequest.of o "Sort.Direction.ASC" ou "Sort.Direction.DESC" que definem se os registros
serão listados em ordem crescente ou descrescente com relação ao parâmetro de ordenação e o campo "ordenacao" a ser preenchido no corpo do link, assim como
a pagina e qtd.


aula 1 atividade 6 - ORDENANDO REGISTROS NA LISTA

> Vimos que, para ordenar os registros, foi necessário passar um parâmetro com o nome do atributo para realizar a ordenação. 
O que acontece se o nome do atributo informado estiver incorreto?
**Um erro será devolvido ao cliente** (Erro 500 pois o parâmetro não foi encontrado)

aula 1 atividade 7 - SIMPLIFICANDO A PAGINAÇÃO E ORDENAÇÃO
"Substituição dos parâmetros soltos de paginação e ordenação por um parâmetro do objeto Pageable para simplificação, adicionada a anotação @EnableSpringDataWebSupport no ForumApplication e definidos com @PageableDefault valores padrão caso não haja passagem de parâmetros em url pelo cliente"
metodo lista foi modificado para não "pegar" os parametros de pagina, qtd e ordenacao soltos e serem todos definidos pelo parametro "paginacao",
objeto do tipo pageable.  
Para o spring conseguir pegar os parametros de paginação e ordenação da requisição, é necessário que o módulo esteja habilitado no projeto,
o módulo que pega as coisas da web e passa para o Spring Data.
Foi alterada a classe ForumApplication (main do Spring Boot) com a anotação @EnableSpringDataWebSupport sobre a declaração da classe.
Assim foi habilitado o suporte para o Spring pegar da requisição, dos parâmetros da url os campos, informações de paginação e orndenação
e repassar ao Spring Data.
Por conta disso, os parâmetros a serem passados na url agora deverão ser em inglês.
EX:http://localhost:8080/topicos?page=0&size=10&sort=id,asc (sort: ordenação, size: qtd, asc CRESCENTE ou desc DECRESCENTE)
o parâmetro sort pode ser usado mais de uma vez para definir mais de um parâmetro de ordenação.
se não for passado parâmetro de ordenação nem paginacao e quantidade, o spring usa o padrão de ordenação pelo id. mas também é possível definir uma ordem padrão caso ela não 
seja passada na url pelo cliente, através da anotação @PageableDefault com parâmetros sort, direction, page e size preenchidos entre parênteses.

aula 1 atividade 8

> Qual o objetivo da anotação @PageableDefault?
**Indicar o padrão de paginação/ordenação ao Spring, quando o cliente da API não enviar tais informações**

Nesta aula, aprendemos que:

>> Para realizar paginação com Spring Data JPA, devemos utilizar a interface Pageable;
>> Nas classes Repository, os métodos que recebem um pageable como parâmetro retornam objetos do tipo Page<>, ao invés de List<>;
>> Para o Spring incluir informações sobre a paginação no JSON de resposta enviado ao cliente da API, devemos alterar o retorno 
do método do controller de List<> para Page<>;
>> Para fazer a ordenação na consulta ao banco de dados, devemos utilizar também a interface Pageable, passando como parâmetro 
a direção da ordenação, utilizando a classe Direction, e o nome do atributo para ordenar;
>> Para receber os parâmetros de ordenação e paginação diretamente nos métodos do controller, devemos habilitar o módulo 
SpringDataWebSupport, adicionando a anotação @EnableSpringDataWebSupport na classe ForumApplication.

-----------------------------------------------------------------------------------------------------------------------------------------------------------

aula 2 atividade 2 - UTILIZANDO CACHE

Utilização do recurso de Cache para melhorar a performance da API

é necessário adicionar o módulo de cache no spring boot como dependência no mavem no arquivo pom.xml
adicionar um provedor de cache como dependência (quando o projeto estiver em ambiente produção, no curso não será adicionado)
o spring por padrão utiliza um provedor de cache não indicado para uso em produção, em hash map, que utilizaremos.

além de declarar dependência de cache no projeto é necessário habilitar o uso do cache no projeto, 
na classe Forum Application com a anotação "@EnableCaching".
Agora é possível utilizar. e para indicar ao spring que queremos a utilização de cache no método, deve ser adicionada
a anotação "@Cacheable", assim a gente indica que queremos o retorno do método em cache.
DEVE SER ADICIONADA A ANOTAÇÃO DO PACOTE SRPING, NÃO DO JAVAX!!!
A anotação deve ser preenchida com um atributo value, que receberá uma String que será o identificador único desse cacheable
usado para identificação, pois um projeto pode conter mais de um cacheable.
para visualizarmos o funcionamento correto do retorno em cache, será adicionado no arquivo application.properties
nas propriedades da jpa "spring.jpa.properties.hibernate.show_sql=true", que fala para o Hibernate imprimir os comandos
sql cada vez que ele acessar o banco de dados.
por padrão, ele imprime todas as propriedades numa linha só, para a formatação das informações impressas
deverá ser adicionada a seguinte propriedade: "spring.jpa.properties.hibernate.format_sql=true"
após salvar, testamos o envio da requisição no postman. no primeiro envio, é mostrado na Run do ForumApplication do Intellij
a consulta que o hibernate realizou no banco de dados porém ao limpar o Run e executar a requisição novamente, não são
mostrados dados de consulta no banco, pois ele mostra resultados buscados no cache (em memória) da consulta anterior,
o que é mais rápido e fácil que consultar no banco novamente nos proporciona ganho de performance.
***Para cada variação de parâmetro na consulta, o spring guarda o resultado na memória cache, se houver mudança de parâmetro
com um resultado ainda não buscado, o hibernate fará a consulta no banco e salvará o resultado para próximas buscas***


"Utilizando Cache: adicionada dependência no pom.xml, habilitado o uso no ForumApplication, indicado uso no método lista da classe 
TopicosController e adicionadas propriedades de visualização e formatação de consultas no banco no Run pelo Hibernate no application.properties"


aula 2 parte 3 - ANOTAÇÃO @CACHEABLE

> No último vídeo, vimos que a anotação @Cacheable possui o parâmetro value, do tipo String. Para que serve esse parâmetro?
**Para indicar ao Spring o nome do cache associado a um determinado método**
A string passada como parâmetro para a anotação @Cacheable funciona como um identificador único do cache.

aula 2 parte 4 - INVALIDANDO O CACHE

para casos de informações serem atualizadas na api com alterações, adicionamentos ou exclusões, será necessário a invalidação do cache para
que a busca não traga informações desatualizadas.
o spring precisará ser avisado de alterar os dados do cache assim que uma informação for atualizada.

Para isso, deverá ser adicionada a anotação "@CacheEvict" sobre o método desejado com o atributo value preenchido indicando qual cacheable deverá ser limpo e 
também o parâmetro "allEntries", que indicará se deverá limpar todos os registros (nesse caso, com a propriedade "true"), assim cada vez que o método 
for utilizado o spring limpará o cache salvo na memória para atualização das informações.
ex: sobre os métodos cadastrar, atualizar e remover foi adicionada a anotação "@CacheEvict(value = "listaDeTopicos", allEntries = true)".
em testes no Postman, funcionou perfeitamente.

"Invalidação do cache para caso de atualização das informações cadastradas na API, utilizando a 
anotação @CacheEvict nos métodos necessários da classe TopicosController com seus respectivos 
parâmetros."


aula 2 atividade 5 - SOBRE A ANOTAÇÃO @CACHEEVICT

> Sobre a utilização da anotação @CacheEvict, é correto afirmar que:
** Ela deveria ser utilizada nos métodos que alteraram os registros armazenados em cache pela API **
(Isso é importante para evitar que os clientes obtenham informações desatualizadas.)
** Devemos indicar, no parâmetro value, quais caches devem ser invalidados **
(Nesse parâmetro devemos indicar os identificadores dos caches que deverão ser invalidados.)


aula 2 atividade 6 - BOAS PRÁTICAS NO USO DE CACHE

Cache é um recurso utilizado para ganhar performance na aplicação, principalmente quando é utilizado o banco de dados.
Porém, na prática o cache tem necessidade de ser invalidado em alguns momentos, o que tem um custo de processamento e 
dependendo do caso pode impactar negativamente na performance da API, ao invés de ser vantajoso.
Por isso, não se deve utilizar o cache em toooodos os lugares, mas sim onde fizer a diferença real no uso.
No geral, faz sentido utilizar o cache em tabelas que nunca ou raramente são atualizadas (por exemplo, no projeto do curso
não seria um bom cenário, pois os tópicos de um fórum são atualizados constantemente), como tabelas de estados, endereços
propriedades e afins.

Nesta aula, aprendemos que:

>> Para utilizar o módulo de cache do Spring Boot, devemos adicioná-lo como dependência do projeto no arquivo pom.xml;
>> Para habilitar o uso de caches na aplicação, devemos adicionar a anotação @EnableCaching na classe ForumApplication;
>> Para que o Spring guarde o retorno de um método no cache, devemos anotá-lo com @Cacheable;
>> Para o Spring invalidar algum cache após um determinado método ser chamado, devemos anotá-lo com @CacheEvict;
>> Devemos utilizar cache apenas para as informações que nunca ou raramente são atualizadas no banco de dados.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AULA 3 Proteção com Spring Security

Aula 3 atividade 2 - Habilitando o Spring Security

Em uma aplicação, costuma-se ter um controle de acesso para restrições de quem pode disparar requisições para a API, tendo permissão para acessar determinados
recursos. O Spring Boot possui um módulo focado na parte de segurança voltado a autenticação e autorização, o Spring Security.
O primeiro passo para proteger a API é baixar o módulo do Spring Security, adicionando como dependência no arquivo pom.xml do Maven.
O segundo passo é configurar a utilização. As configurações com spring boot são feitas no arquivo application.properties, mas como a parte de segurança
é complicada pois há várias configurações e muitas dinâmicas e não fixas, nesse caso não utilizaremos o application.properties para as configurações, então
ela será realizada toda em classe Java. Será necessário criar um classe onde terão todas as configurações de segurança da API.
A classe será criada dentro do pacote security, adicionado dentro do pacote config e será denominada SecurityConfigurations
O módulo de segurança é habilitado na API adicionando a anotação @EnableWebSecurity sobre o nome da classe.
Como é uma classe que haverá configurações, é necessário adicionar a anotação @Configuration, assim ao rodar o projeto o Spring lerá
a classe sabendo que nela há configurações para todo projeto. Além disso, a classe será extendida da classe "WebSecurityConfigurerAdapter" pois ela tem métodos para fazer
as configurações que serão sobrescrevidos posteriormente.
Por padrão, com a classe já montada dessa maneira já faz o projeto estar protegido pois o spring bloqueia toda a aplicação
até que sejam feitas as devidas configurações.

"Baixar, configurar como dependência no arquivo pom.xml e habilitar na classe SecurityConfigurations o módulo Spring Security"


Aula 3 atividade 3 - Spring Security e os endpoints da API

> Ao habilitar o Spring Security, o que acontecerá com os endpoints da API?
** Eles serão bloqueados, por padrão **


Aula 3 atividade 4 - Liberando acesso aos endpoints públicos

Faremos sobrescrita com as regras da nossa aplicação métodos de autenticação e autorização pertencentes a classe WebSecurityConfigureAdapter, a qual
a classe SecurityConfigurations possui herança. Serão utilizados 3 métodos "Configure". Mas qual a diferença entre os 3?
> O método que recebe o "AuthenticationManagerBuilder auth", serve para configurar autenticações;
> O método que recebe "HttpSecurity http" serve para configurações de autorização (urls e quem pode acessá-las, etc)
> O método que recebe "WebSecurity web" serve para configurações de recursos estáticos, como requisições para arquivos .js, css, imagens...
Utilizaremos o método que recebe "HttpSecurity http", onde faremos configuração das urls do projeto, do que será público e privado.
No projeto será liberado como público o endpoint que lista todos os tópicos "/topicos" e o que detalha um tópico em específico. Os outros (cadastrar, alterar e excluir)
serão restringidos.

"Implementada a liberação de acesso aos endpoints públicos (métodos para lista de tópicos e detalhamento de tópicos) na classe SecurityConfigurations"  


Aula 3 atividade 5 - Por que indicar o método GET?

> Vimos no vídeo anterior que, para liberar acesso ao endpoint de lista de tópicos, foi necessário adicionar a seguinte linha de código:
------ antMatchers(HttpMethod.GET, /topicos).permitAll(); ------
Por que foi necessário indicar o método GET nessa configuração?

** Para liberar acesso apenas às requisições do tipo GET **
(Se não indicarmos o método HTTP, todos seriam permitidos.)

Aula 3 atividade 6 - Restringindo acesso aos endpoints privados

A ideia é restringir os métodos de alterar, cadastrar e excluir e exigir autenticação para realizar as alterações na API.
Deveremos implementar a parte de autenticação: no pacote modelo já temos uma classe Usuario e utilizaremos dela para o usuário se autenticar no sistema. É uma classe
de domínio da aplicação e foi transformada numa entidade da JPA, tendo já no banco uma tabela para guardar as informações. Porém, o Spring Security precisa saber
que essa classe representa o usuário! Como?
Será necessário implementar na classe uma interface, a UserDetails e implementar todos os métodos dela.
nos métodos de getUsername e getPassword devemos indicar no retorno o "this.nomedoatributoquechamaoqueénecessário", ex: return this.email para "getUsername".
os métodos que possuem retorno em boolean são métodos para controle de autenticação em casos do usuário estar desativado e afins, como não utilizaremos
desses detalhes, todos serão configurados com "return true".
O método que precisa devolver um Collection<? de GrantedAuthority> é relacionado a coleção com os perfis do usuário. Seu retorno será preenchido com a indicação para
uma lista de perfis, o qual foi necessário implementar na classe e deverá ser criada uma classe Perfil que será uma entidade da JPA e será necessário criar uma
tabela para guardar no banco os perfis. A classe perfil foi criada no pacote modelo, que terá como atributo o id e o nome, que será o nome do perfil.
Mesmo configurado, o método da classe Usuário continua dando erro pois ela deve herdar da interface GrantedAuthority, então a classe que representa o perfil
deverá implementar uma interface para indicar ao Spring que ela representa o perfil de acesso, a interface GrantedAuthority e implementar seu método o getAuthority
que deverá devolver o atributo que denomina o perfil, o atributo "nome". Após as configurações na classe Usuario e Perfil, vamos voltar para SecurityConfigurations
e utilizando o comando ".and().formLogin();" indicamos ao Spring a continuação da implementação e solicitamos que ele gere (chame) um formulário de autenticação e 
um controller que recebe as requisições desse formulário.

"Realizada implementação para restringir acesso aos endpoints privados com base na requisição de autenticação ao usuário"


Aula 3 atividade 7 - Objetivo do método anyRequest().authenticated()

> Nas configurações de autorização, qual o objetivo de chamar o método anyRequest().authenticated()?
** Para indicar que outras URLs que não foram configuradas devem ter acesso restrito **
(Essa configuração evita que uma URL que não foi configurada seja pública.)

Aula 3 atividade 8 - Autenticando o usuário

A configuração de autenticação do projeto será realizada no método configure(AuthenticationManagerBuilder auth), na classe Security Configurations.
O método recebe uma variável auth, utilizaremos ela junto a chamada do método userDetailsService, o qual pede em parênteses qual a classe/service que 
terá a lógica de autenticação implementada. Passaremos como parametro autenticacaoService e criaremos essa classe para implementar as regras de
autenticação nela. Em cima da classe, será adicionada a anotação @Service e para dizer ao spring que essa Service tem a lógica de autenticação 
necessária, implementaremos a interface UserDetailsService, adicionando também o método loadUserByUsername, que é o método que o spring chama no login, para 
localizar o usuário ele busca através desse método no banco de dados e a senha ele buscará em memória para fazer a checagem. 
Será necessário criar uma nova interface UsuarioRepository no pacote repository para implementação. Nela, importamos a classe Usuario, extendemos
a classe JpaRepository e a declaração de método "Usuario findByEmail(String email)" para que o spring busque o usuário pelo email fornecido.
Voltando a classe AutenticacaoService, chamaremos o repository pelo atributo de tipo UsuarioRepository com a anotação @Autowired e para fazer a consulta
chamaremos o método findByEmail, passando como parâmetro o username. Vamos guardar o resultado numa variável usuario de tipo Usuario (importar classe).
Se o método find não encontrar o usuário, devolverá um erro. Faremos o mesmo esquema do método detalhar na classe TopicosController (optional que devolve
exception), alterando UsuarioRepository e adicionando um if no Service; caso o spring não ache o usuário, o retorno será uma exception.
Voltando para SecurityConfigurations, será necessário adicionar o AutenticacaoService. Criaremos uma variável autenticacaoService de mesmo tipo (conforme a classe)
com a anotação @Autowired.
Para testar, precisamos ter um usuário cadastrado no banco de dados, que já temos. Lembra daquele arquivo data.sql? Naquele script de inicialização do 
banco de dados eu criei um registro para o usuário. O e-mail dele é alura@email,com, a senha é 123456. Porém, em qualquer aplicação deixar a senha em 
aberto no banco de dados não é uma boa prática. Geralmente o pessoal utiliza algum algoritmo para gerar um HASH dessa senha e salva no banco de dados a 
senha com o HASH. Também vamos fazer isso na classe de autenticação. Nós chamamos o auth, o UserDetailsService, só que antes do ponto e vírgula colocamos 
um passwordEncoder. Conseguimos dizer para ele qual o algoritmo de HASH que vamos utilizar para a senha. O Spring suporta alguns algoritmos que são seguros, 
um deles é o tal do BCrypt. Posso instanciar um objeto BCryptPasswordEncoder. É uma classe do próprio Spring security que já implementa a geração do algoritmo 
do HASH, da senha, usando o algoritmo específico. Só que no nosso data.sql, quando ele vai criar um usuário no banco, ele está jogando a senha em texto aberto. 
Tenho que passar um valor que é o HASH no formato do BCrypt. Para facilitar, vou na minha classe SecurityConfigurations e vou dar um system out, 
vou chamar o método encode e vou passar a senha 123456. Se eu rodar esse main, só estou falando para ele pegar o BCrypt e gerar o HASH da senha.
No arquivo SQL vou trocar a senha pela senha criptografada. Vou voltar no SecurityConfiguration e vou apagar o main, só para termos a tenha gerada. Agora, 
já consigo simular. Vou tentar me autenticar com aquele usuário. Digitando a senha errada, tento logar, ele não permite. Com a senha certa, funciona. 
E a partir de agora consigo chamar os endpoints que estão restritos.


"Realizada as implementações necessárias para configurar a autenticação para acesso as endpoints privadas."

Aula 3 atividade 9 - LÓGICA DE AUTENTICAÇÃO

> No vídeo anterior, vimos que foi necessário criar uma classe, implementando a interface UserDetailsService do Spring Security. Qual o objetivo dessa classe?
** Para indicar ao Spring Security que essa é a classe service que executa a lógica de autenticação **
(A classe que implementa essa interface geralmente contém uma lógica para validar as credenciais de um cliente que está se autenticando.)


Nesta aula, aprendemos que:

>> Para utilizar o módulo do Spring Security, devemos adicioná-lo como dependência do projeto no arquivo pom.xml;
>> Para habilitar e configurar o controle de autenticação e autorização do projeto, devemos criar uma classe e anotá-la com @Configuration e @EnableWebSecurity;
>> Para liberar acesso a algum endpoint da nossa API, devemos chamar o método http.authorizeRequests().antMatchers().permitAll() d
entro do método configure(HttpSecurity http), que está na classe SecurityConfigurations;
>> O método anyRequest().authenticated() indica ao Spring Security para bloquear todos os endpoints que não foram liberados anteriormente com o método permitAll();
>> Para implementar o controle de autenticação na API, devemos implementar a interface UserDetails na classe Usuario e também implementar a interface GrantedAuthority 
na classe Perfil;
>> Para o Spring Security gerar automaticamente um formulário de login, devemos chamar o método and().formLogin(), dentro do método configure(HttpSecurity http), 
que está na classe SecurityConfigurations;
>> A lógica de autenticação, que consulta o usuário no banco de dados, deve implementar a interface UserDetailsService;
>> Devemos indicar ao Spring Security qual o algoritmo de hashing de senha que utilizaremos na API, chamando o método passwordEncoder(), 
dentro do método configure(AuthenticationManagerBuilder auth), que está na classe SecurityConfigurations.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AULA 4 - GERANDO TOKEN COM JWT

Aula 4 Atividade 2 - POR QUE AUTENTICAR VIA TOKEN

Numa API de modelo REST, o ideal é que a autenticação seja feita por stateless. Ou seja, o cliente dispara uma requisição, leva todas as informações necessárias, 
o servidor processa, executa o que tem que executar, devolve a resposta e acabou. No modelo tradicional via session, cada acesso cria um espaço na memória e são
diferenciados por um ID único e o ID é devolvido como resposta para o navegador no formato de um Cookie e nas próximas requisições que esse usuário fizer por esse
navegador, o browser automaticamente envia esse parâmetro como cookie já registrado. ISSO VAI CONTRA O PRINCÍPIO DO REST, que consiste em ser stateless. 
Com o Spring Security, é possível configurar para que o Spring não crie uma session a cada login e se comporte de acordo com o modelo stateless, mas nas próximas 
requisições do usuário o servidor não saberá se ele está logado ou não pois não há informações armazenadas na memória e por isso o usuário precisa enviar alguma 
informação. Isso é realizado via token, a cada requisição o cliente mandará um token para identificá-lo e mostrar se ele possui as devidas permissões.

AULA 4 Atividade 3 - CONFIGURANDO AUTENTICAÇÃO STATELESS

Vamos aprender a como não utilizar sessão e fazer a autenticação no modelo stateless seguindo as boas práticas do modelo Rest.
Utilizaremos o JSON WEB TOKEN, que é uma tecnologia para geração de tokens e autenticação de maneira stateless. Para isso, precisamos utilizar alguma Biblioteca
em JAVA que siga o modelo web token, a JJWT. Então ela será adicionada como dependência no arquivo pom.xml (maven) do projeto.
Após o maven baixar a dependência, precisamos atualizar o arquivo SecurityConfigurations para informar ao Spring Security que a autenticação não mais será feita 
por sessão, mas por modelo stateless. Isso será realizado no método Configure, onde foram configuradas as URLS, o principal método da classe. Retiramos o login por
formulário (o que faria autenticação por sessão) e desabilitaremos a autenticação do token csrf.
Adicionaremos .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); (chamamos o método para dizer que não queremos utilizar sessão e avisamos
o Spring Security que utilizaremos token com maneira stateless.
Porém, como apagamos o form de login, a partir de agora não temos formulário de login gerado pelo Spring. Então quem fornecerá o formulário de login na API será o
cliente no frontEnd. Além disso, perdemos o controller que faz a parte de autenticação pois era gerado pelo Spring. Então, deveremos criar uma nova classe Controller
para cuidar da autenticação.
Na classe AutenticacaoController, adicionamos @RestController @RequestMapping("/auth") sobre a classe e definiremos um método para ter a lógica de autenticação.
O método autenticar que devolve ResponseEntity e terá o @PostMapping, pois o método será chamado caso a requisição seja /auth via método Post.
O método será chamado quando o cliente solicitar ao usuário os dados de login e senha. Os parâmetros serão o login e senha, que virão no corpo da requisição (@RequestBody)
e vamos validar os dados também (@Valid). Não vamos receber os dados soltos, pelo LoginForm, a nova classe que criaremos para receber os dados em tipo correto.
Dentro da LoginForm, teremos apenas os atributos de email e senha e seus getters setters, que o cliente enviará como o json esses dados para a classe.
No primeiro momento, vamos fazer um system out com form. get email e um com get senha para saber se os dados corretos estão chegando e o retorno será
return ResponseEntity.ok().build();
Agora vamos testar no Postman. O teste deu erro 403 forbidden porque esquecemos de liberar a url. Toda nova url deverá ser liberada no metodo configure
da classe SecurityConfigurations. No código, falaremos para o Spring Security que requisições do tipo Post para "/auth", permite all. Após salvo, o teste funcionou.

"Primeiras configurações em código/classes para o uso de autenticação via token no modelo Stateless: autalização da SecurityConfigurations para o modelo 
starteless, criada a AutenticacaoController e a LoginForm para cuidar da autenticação e receber os dados de login, respectivamente"

AULA 4 Atividade 4 - Página de login

> No vídeo anterior, tivemos que remover a chamada ao método and().formLogin() da classe SecurityConfigurations. 
Mas dessa maneira, como um usuário vai se autenticar na API?
** O usuário deverá se autenticar por uma página de login fornecida pela própria aplicação cliente **
(A aplicação cliente deve ter uma página de login, que faz a chamada ao endpoint de autenticação da API.)


AULA 4 Atividade 5 - Gerando Tokens com JWT

Foi implementado o Controller com a parte de autenticação, que recebe os dados de autenticação de usuário e senha. O próximo passo é autenticar no Spring
e fazer a geração do token. Como não estamos mais utilizando o Formulário do Spring que já possuía um Controller que fazia a chamada para a autenticação, teremos
que fazer a chamada de autenticação manualmente. Vamos remover os System.out da classe autenticar e para fazer a autenticação de maneira programática, manual, 
precisaremos injetar a classe AutenticationManager, declarando um atributo de seu tipo, com anotação @Autowired. Porém, a classe é do Spring mas ele não consegue
puxar as dependências dela automaticamente, a não ser que seja configurado isso. Deveremos configurar na Classe SecurityConfigurations. Na classe que estamos herdando
já há um método que "sabe" herdar o AuthenticationManager, então vamos apenas sobrescrever o método na classe e colocar o @Bean sobre a classe para assim o Spring
saber que esse método devolve o AuthenticationManager e assim conseguiremos injetá-lo no Controller.
Voltando ao Controller, chamaremos o atributo authManager junto ao método authenticate e os dados necessários para fazer a autenticação, passando o email e senha
não soltos, mas um objeto específico que criaremos acima do tipo UsernamePasswordAuthenticationToken, chamado de dadosLogin. Dentro do objeto deverão ser passados
com new o login e senha e faremos o esquema que já fizemos no TopicoController, pegar o form e criar o método converter, que fará a conversão com os dados que o form
precisa com os dados dentro do form; então criamos o méotodo converter na classe LoginForm, com retorno return new UsernamePasswordAuthenticationToken(email, senha);
Essa é a classe (AutenticacaoController) que o Spring precisa para realizar a autenticação e o método autenticar devolve um objeto que vamos guardar numa variável
de tipo Authentication. Quando o Spring chamar essa linha de código ele vai ver as configurações e saberá que deve chamar a AuthenticationService, que chama o usuarioRepository.
Se der certo, devolveremos "ok" mas se não (login e senha errado), ele devolverá uma exception. Então vamos fazer um tratamento com um try catch. 
Se der ok, vamos devolver o Token (que será armazenado numa String), então precisamos gerá-lo com a biblioteca JJWT porém para não deixarmos seu código solto, ele será
isolado numa classe TokenService (uma @Service), com um método gerarToken. Na hora de gerar o token, precisaremos identificar o usuário dono do token, então nesse método, 
passaremos o authentication como parâmetro. No método gerarToken dentro da classe TokenService vamos colocar a API do JJWT para fazer a geração do token.
No método vamos precisar injetar uma propriedade relacionada ao tempo de expiração do token gerado e uma senha presentes no application.properties. Mas como isso deverá
ser feito? Iremos declarar um atributo na classe (expiration do tipo String e secret para a senha) e para injetá-los, utilizamos a anotação @Value que recebe um parâmetro, 
que é o nome da propriedade. Dessa maneira o Spring vai ler o parâmetro, ver que está em application.properties e injetar a propriedade lá presente.
Salvas todas as configurações para geração do token no método (explicados nos comentários do código), vamos inserir um system.out dentro do método autenticar imprimindo
o token e faremos o teste no postman.
No próximo exercício, vamos ver como no controller podemos fazer para devolver esse token, porque aqui eu só fiz o system out para ver se está tudo ok.

"Realizadas configurações para o Spring fazer a geração de Token a partir da autenticação na classe de Controller, na classe de dados do login e na SecurityConfigurations"

AULA 4 Atividade 6 - Injeção de Propriedades

> No último vídeo, vimos que é possível fazer injeção de dependências de propriedades do arquivo application.properties. Dos exemplos de código abaixo, 
qual deles faz a injeção de propriedades de maneira correta?
** @Value(${forum.jwt.secret})
private String secret; **
(A anotação @Value deve declarar o nome da propriedade como String, utilizando a expression language ${}.)

