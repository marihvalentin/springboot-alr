spring boot parte dois

aula 1 atividade 2 - PAGINAÇÃO
"modificação no método lista dentro do controller para adicionar paginação"
na listagem dos resultados. envolveu adaptação na interface TopicoRepository e 
na classe TopicoDto, método converter.

aula 1 atividade 4 - VANTAGEM DE UTILIZAR A INTERFACE PAGE

> Como vimos no vídeo anterior, foi necessário alterar o retorno do método lista, de List<Topico>, para Page<Topico>. 
Qual a vantagem de devolver um objeto Page, ao invés de um List? 
**Adicionar dados sobre a paginação no JSON de resposta**
Ao utilizar o objeto Page, além de devolver os registros, o Spring também devolve informações sobre a paginação no JSON de resposta , 
como número total de registros e páginas.

aula 1 atividade 5 - ORDENAÇÃO
"melhorada a listagem paginada dentro do controller e atribuída opção de ordenação personalizada dos resultados pelo cliente alterando a lógica do método lista"
foi adicionado o atributo ordenação como RequestParam e dentro do PageRequest.of o "Sort.Direction.ASC" ou "Sort.Direction.DESC" que definem se os registros
serão listados em ordem crescente ou descrescente com relação ao parâmetro de ordenação e o campo "ordenacao" a ser preenchido no corpo do link, assim como
a pagina e qtd.


aula 1 atividade 6 - ORDENANDO REGISTROS NA LISTA

> Vimos que, para ordenar os registros, foi necessário passar um parâmetro com o nome do atributo para realizar a ordenação. 
O que acontece se o nome do atributo informado estiver incorreto?
**Um erro será devolvido ao cliente** (Erro 500 pois o parâmetro não foi encontrado)

aula 1 atividade 7 - SIMPLIFICANDO A PAGINAÇÃO E ORDENAÇÃO
"Substituição dos parâmetros soltos de paginação e ordenação por um parâmetro do objeto Pageable para simplificação, adicionada a anotação @EnableSpringDataWebSupport no ForumApplication e definidos com @PageableDefault valores padrão caso não haja passagem de parâmetros em url pelo cliente"
metodo lista foi modificado para não "pegar" os parametros de pagina, qtd e ordenacao soltos e serem todos definidos pelo parametro "paginacao",
objeto do tipo pageable.  
Para o spring conseguir pegar os parametros de paginação e ordenação da requisição, é necessário que o módulo esteja habilitado no projeto,
o módulo que pega as coisas da web e passa para o Spring Data.
Foi alterada a classe ForumApplication (main do Spring Boot) com a anotação @EnableSpringDataWebSupport sobre a declaração da classe.
Assim foi habilitado o suporte para o Spring pegar da requisição, dos parâmetros da url os campos, informações de paginação e orndenação
e repassar ao Spring Data.
Por conta disso, os parâmetros a serem passados na url agora deverão ser em inglês.
EX:http://localhost:8080/topicos?page=0&size=10&sort=id,asc (sort: ordenação, size: qtd, asc CRESCENTE ou desc DECRESCENTE)
o parâmetro sort pode ser usado mais de uma vez para definir mais de um parâmetro de ordenação.
se não for passado parâmetro de ordenação nem paginacao e quantidade, o spring usa o padrão de ordenação pelo id. mas também é possível definir uma ordem padrão caso ela não 
seja passada na url pelo cliente, através da anotação @PageableDefault com parâmetros sort, direction, page e size preenchidos entre parênteses.

aula 1 atividade 8

> Qual o objetivo da anotação @PageableDefault?
**Indicar o padrão de paginação/ordenação ao Spring, quando o cliente da API não enviar tais informações**

Nesta aula, aprendemos que:

>> Para realizar paginação com Spring Data JPA, devemos utilizar a interface Pageable;
>> Nas classes Repository, os métodos que recebem um pageable como parâmetro retornam objetos do tipo Page<>, ao invés de List<>;
>> Para o Spring incluir informações sobre a paginação no JSON de resposta enviado ao cliente da API, devemos alterar o retorno 
do método do controller de List<> para Page<>;
>> Para fazer a ordenação na consulta ao banco de dados, devemos utilizar também a interface Pageable, passando como parâmetro 
a direção da ordenação, utilizando a classe Direction, e o nome do atributo para ordenar;
>> Para receber os parâmetros de ordenação e paginação diretamente nos métodos do controller, devemos habilitar o módulo 
SpringDataWebSupport, adicionando a anotação @EnableSpringDataWebSupport na classe ForumApplication.

-----------------------------------------------------------------------------------------------------------------------------------------------------------

aula 2 atividade 2 - UTILIZANDO CACHE

Utilização do recurso de Cache para melhorar a performance da API

é necessário adicionar o módulo de cache no spring boot como dependência no mavem no arquivo pom.xml
adicionar um provedor de cache como dependência (quando o projeto estiver em ambiente produção, no curso não será adicionado)
o spring por padrão utiliza um provedor de cache não indicado para uso em produção, em hash map, que utilizaremos.

além de declarar dependência de cache no projeto é necessário habilitar o uso do cache no projeto, 
na classe Forum Application com a anotação "@EnableCaching".
Agora é possível utilizar. e para indicar ao spring que queremos a utilização de cache no método, deve ser adicionada
a anotação "@Cacheable", assim a gente indica que queremos o retorno do método em cache.
DEVE SER ADICIONADA A ANOTAÇÃO DO PACOTE SRPING, NÃO DO JAVAX!!!
A anotação deve ser preenchida com um atributo value, que receberá uma String que será o identificador único desse cacheable
usado para identificação, pois um projeto pode conter mais de um cacheable.
para visualizarmos o funcionamento correto do retorno em cache, será adicionado no arquivo application.properties
nas propriedades da jpa "spring.jpa.properties.hibernate.show_sql=true", que fala para o Hibernate imprimir os comandos
sql cada vez que ele acessar o banco de dados.
por padrão, ele imprime todas as propriedades numa linha só, para a formatação das informações impressas
deverá ser adicionada a seguinte propriedade: "spring.jpa.properties.hibernate.format_sql=true"
após salvar, testamos o envio da requisição no postman. no primeiro envio, é mostrado na Run do ForumApplication do Intellij
a consulta que o hibernate realizou no banco de dados porém ao limpar o Run e executar a requisição novamente, não são
mostrados dados de consulta no banco, pois ele mostra resultados buscados no cache (em memória) da consulta anterior,
o que é mais rápido e fácil que consultar no banco novamente nos proporciona ganho de performance.
***Para cada variação de parâmetro na consulta, o spring guarda o resultado na memória cache, se houver mudança de parâmetro
com um resultado ainda não buscado, o hibernate fará a consulta no banco e salvará o resultado para próximas buscas***


"Utilizando Cache: adicionada dependência no pom.xml, habilitado o uso no ForumApplication, indicado uso no método lista da classe 
TopicosController e adicionadas propriedades de visualização e formatação de consultas no banco no Run pelo Hibernate no application.properties"


aula 2 parte 3 - ANOTAÇÃO @CACHEABLE

> No último vídeo, vimos que a anotação @Cacheable possui o parâmetro value, do tipo String. Para que serve esse parâmetro?
**Para indicar ao Spring o nome do cache associado a um determinado método**
A string passada como parâmetro para a anotação @Cacheable funciona como um identificador único do cache.

aula 2 parte 4 - INVALIDANDO O CACHE

para casos de informações serem atualizadas na api com alterações, adicionamentos ou exclusões, será necessário a invalidação do cache para
que a busca não traga informações desatualizadas.
o spring precisará ser avisado de alterar os dados do cache assim que uma informação for atualizada.

Para isso, deverá ser adicionada a anotação "@CacheEvict" sobre o método desejado com o atributo value preenchido indicando qual cacheable deverá ser limpo e 
também o parâmetro "allEntries", que indicará se deverá limpar todos os registros (nesse caso, com a propriedade "true"), assim cada vez que o método 
for utilizado o spring limpará o cache salvo na memória para atualização das informações.
ex: sobre os métodos cadastrar, atualizar e remover foi adicionada a anotação "@CacheEvict(value = "listaDeTopicos", allEntries = true)".
em testes no Postman, funcionou perfeitamente.

"Invalidação do cache para caso de atualização das informações cadastradas na API, utilizando a 
anotação @CacheEvict nos métodos necessários da classe TopicosController com seus respectivos 
parâmetros."


aula 2 atividade 5 - SOBRE A ANOTAÇÃO @CACHEEVICT

> Sobre a utilização da anotação @CacheEvict, é correto afirmar que:
** Ela deveria ser utilizada nos métodos que alteraram os registros armazenados em cache pela API **
(Isso é importante para evitar que os clientes obtenham informações desatualizadas.)
** Devemos indicar, no parâmetro value, quais caches devem ser invalidados **
(Nesse parâmetro devemos indicar os identificadores dos caches que deverão ser invalidados.)


aula 2 atividade 6 - BOAS PRÁTICAS NO USO DE CACHE

Cache é um recurso utilizado para ganhar performance na aplicação, principalmente quando é utilizado o banco de dados.
Porém, na prática o cache tem necessidade de ser invalidado em alguns momentos, o que tem um custo de processamento e 
dependendo do caso pode impactar negativamente na performance da API, ao invés de ser vantajoso.
Por isso, não se deve utilizar o cache em toooodos os lugares, mas sim onde fizer a diferença real no uso.
No geral, faz sentido utilizar o cache em tabelas que nunca ou raramente são atualizadas (por exemplo, no projeto do curso
não seria um bom cenário, pois os tópicos de um fórum são atualizados constantemente), como tabelas de estados, endereços
propriedades e afins.

Nesta aula, aprendemos que:

>> Para utilizar o módulo de cache do Spring Boot, devemos adicioná-lo como dependência do projeto no arquivo pom.xml;
>> Para habilitar o uso de caches na aplicação, devemos adicionar a anotação @EnableCaching na classe ForumApplication;
>> Para que o Spring guarde o retorno de um método no cache, devemos anotá-lo com @Cacheable;
>> Para o Spring invalidar algum cache após um determinado método ser chamado, devemos anotá-lo com @CacheEvict;
>> Devemos utilizar cache apenas para as informações que nunca ou raramente são atualizadas no banco de dados.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AULA 3 Proteção com Spring Security

Aula 3 atividade 2 - Habilitando o Spring Security

Em uma aplicação, costuma-se ter um controle de acesso para restrições de quem pode disparar requisições para a API, tendo permissão para acessar determinados
recursos. O Spring Boot possui um módulo focado na parte de segurança voltado a autenticação e autorização, o Spring Security.
O primeiro passo para proteger a API é baixar o módulo do Spring Security, adicionando como dependência no arquivo pom.xml do Maven.
O segundo passo é configurar a utilização. As configurações com spring boot são feitas no arquivo application.properties, mas como a parte de segurança
é complicada pois há várias configurações e muitas dinâmicas e não fixas, nesse caso não utilizaremos o application.properties para as configurações, então
ela será realizada toda em classe Java. Será necessário criar um classe onde terão todas as configurações de segurança da API.
A classe será criada dentro do pacote security, adicionado dentro do pacote config e será denominada SecurityConfigurations
O módulo de segurança é habilitado na API adicionando a anotação @EnableWebSecurity sobre o nome da classe.
Como é uma classe que haverá configurações, é necessário adicionar a anotação @Configuration, assim ao rodar o projeto o Spring lerá
a classe sabendo que nela há configurações para todo projeto. Além disso, a classe será extendida da classe "WebSecurityConfigurerAdapter" pois ela tem métodos para fazer
as configurações que serão sobrescrevidos posteriormente.
Por padrão, com a classe já montada dessa maneira já faz o projeto estar protegido pois o spring bloqueia toda a aplicação
até que sejam feitas as devidas configurações.

"Baixar, configurar como dependência no arquivo pom.xml e habilitar na classe SecurityConfigurations o módulo Spring Security"


Aula 3 atividade 3 - Spring Security e os endpoints da API

> Ao habilitar o Spring Security, o que acontecerá com os endpoints da API?
** Eles serão bloqueados, por padrão **


Aula 3 atividade 4 - Liberando acesso aos endpoints públicos

Faremos sobrescrita com as regras da nossa aplicação métodos de autenticação e autorização pertencentes a classe WebSecurityConfigureAdapter, a qual
a classe SecurityConfigurations possui herança. Serão utilizados 3 métodos "Configure". Mas qual a diferença entre os 3?
> O método que recebe o "AuthenticationManagerBuilder auth", serve para configurar autenticações;
> O método que recebe "HttpSecurity http" serve para configurações de autorização (urls e quem pode acessá-las, etc)
> O método que recebe "WebSecurity web" serve para configurações de recursos estáticos, como requisições para arquivos .js, css, imagens...
Utilizaremos o método que recebe "HttpSecurity http", onde faremos configuração das urls do projeto, do que será público e privado.
No projeto será liberado como público o endpoint que lista todos os tópicos "/topicos" e o que detalha um tópico em específico. Os outros (cadastrar, alterar e excluir)
serão restringidos.

"Implementada a liberação de acesso aos endpoints públicos (métodos para lista de tópicos e detalhamento de tópicos) na classe SecurityConfigurations"  


Aula 3 atividade 5 - Por que indicar o método GET?

> Vimos no vídeo anterior que, para liberar acesso ao endpoint de lista de tópicos, foi necessário adicionar a seguinte linha de código:
------ antMatchers(HttpMethod.GET, /topicos).permitAll(); ------
Por que foi necessário indicar o método GET nessa configuração?

** Para liberar acesso apenas às requisições do tipo GET **
(Se não indicarmos o método HTTP, todos seriam permitidos.)



